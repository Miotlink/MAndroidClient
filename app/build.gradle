apply plugin: 'com.android.application'
apply plugin: 'com.neenbedankt.android-apt'
apply plugin: 'com.growingio.android'
apply plugin: 'walle'

android {
    compileSdkVersion parent.ext.compileSdkVersion
    buildToolsVersion parent.ext.buildToolsVersion

//    //multi-apk 是为了根据配置生成不同的APK，以达到减少APK体积大小的问题。但是这个配置没有必要在开发的时候开启。
//    if (project.hasProperty('devBuild')) {
//        splits.abi.enable = false
//        splits.density.enable = false
//        //关闭 png 压缩
//        aaptOptions.cruncherEnabled = false
//    }
//    如果你的app是包含多资源的，比如多语言的和多分辨率。但是在开发的时候，大部分时间都是只用一种资源，所以其他资源就会无用，导致拖慢构建速度。
//    development{
//        resConfigs ("en","xxhdpi")
//    }

    //recommend
    dexOptions {
        jumboMode = true
    }

    lintOptions {
        abortOnError false
        disable "MissingPrefix"
        disable 'MissingTranslation'
    }
    defaultConfig {
        applicationId parent.ext.applicationId
        minSdkVersion parent.ext.minSdkVersion
        targetSdkVersion parent.ext.targetSdkVersion
        versionCode parent.ext.versionCode
        versionName parent.ext.versionName
        multiDexEnabled true
        manifestPlaceholders = [
                JPUSH_PKGNAME: applicationId,
                JPUSH_APPKEY : "912d25a1af02f167dfef8c49", //JPush上注册的包名对应的appkey.
                JPUSH_CHANNEL: "developer-default", //暂时填写默认值即可.
                PACKAGE_NAME : applicationId]
        //executor config
        buildConfigField "int", "CONCURRENT_JOB_EXECUTOR_CORE_POOL_SIZE", "3"
        buildConfigField "int", "CONCURRENT_JOB_EXECUTOR_MAXIMUM_POOL_SIZE", "5"
        buildConfigField "long", "JOB_EXECUTOR_KEPP_ALIVE_TIME_SEC", "10"

        //socialize
        buildConfigField "String", "WECHAT_APP_ID", "\"wx34bcf2cceb9a61a1\""
        buildConfigField "String", "WECHAT_APP_SECRET", "\"82e20f74e890e16f73dd2b05289dc9b0\""
        buildConfigField "String", "QQ_ZONE_APP_ID", "\"1105094056\""
        buildConfigField "String", "QQ_ZONE_APP_KEY", "\"YONfOlwgupMOzcQf\""
        buildConfigField "String", "WEIBO_APP_KEY", "\"3566444211\""
        buildConfigField "String", "WEIBO_APP_SECRET", "\"b565a90f4404b52b6f87d1edb557eae4\""

        //file path
        buildConfigField("String", "PICTURE_PATH", "\"/Sls/Pictures\"")
        buildConfigField("String", "TTS_DATA_PATH", "\"/Sls/tts\"")

        /*RN config*/
        ndk {
            abiFilters "armeabi-v7a", "armeabi-v8a", 'armeabi'
        }
        resValue("string", "growingio_project_id", "867511be982891a9")
        resValue("string", "growingio_url_scheme", "growing.57230639777b2eda")
    }

    /*RN config*/
    packagingOptions {
        exclude "lib/arm64-v8a/librealm-jni.so"
    }

    signingConfigs {
        debug {
            storeFile file("./keystore/slskeystore.jks")
            keyAlias 'slskey'
            keyPassword 'Homepaas123'
            storePassword 'Homepaas123'
        }
        release {
            storeFile file("./keystore/slskeystore.jks")
            keyAlias 'slskey'
            keyPassword 'Homepaas123'
            storePassword 'Homepaas123'
        }
    }
    sourceSets.main {
        jniLibs.srcDir 'src/main/jniLibs'
    }



    buildTypes {
        release {
            minifyEnabled true//混淆
            debuggable false
            jniDebuggable false
            zipAlignEnabled true
            shrinkResources true
//            minifyEnabled false
//            jniDebuggable true
            debuggable true

            buildConfigField("boolean", "APP_IS_DEBUG", "false")
            buildConfigField("String", "Bugly", "\"8ee25041d8\"")

            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
            manifestPlaceholders.put("APP_NAME", "助家生活")

            manifestPlaceholders.put("BD_MAP_API_KEY", "1pPALTmbxveNnEB9AmjZ0wCW")
            manifestPlaceholders.put("UMENG_APPKEY", "568cbf7e67e58ea74f000143")

        }

        developer {
            minifyEnabled false
            jniDebuggable true
            debuggable true
            signingConfig signingConfigs.release
            buildConfigField("boolean", "APP_IS_DEBUG", "true")
            buildConfigField("String", "Bugly", "\"8ee25041d8\"")

            manifestPlaceholders.put("JPUSH_APPKEY", "912d25a1af02f167dfef8c49")
            manifestPlaceholders.put("JPUSH_CHANNEL", "developer-default")
            manifestPlaceholders.put("APP_NAME", "3001助家生活")

            manifestPlaceholders.put("BD_MAP_API_KEY", "1pPALTmbxveNnEB9AmjZ0wCW")
            manifestPlaceholders.put("UMENG_APPKEY", "568cbf7e67e58ea74f000143")
        }

        debug {
            minifyEnabled false
            jniDebuggable true
            debuggable true
            signingConfig signingConfigs.debug
            buildConfigField("boolean", "APP_IS_DEBUG", "true")
            buildConfigField("String", "Bugly", "\"8ee25041d8\"")

            manifestPlaceholders.put("JPUSH_APPKEY", "912d25a1af02f167dfef8c49")
            manifestPlaceholders.put("JPUSH_CHANNEL", "developer-default")
            manifestPlaceholders.put("APP_NAME", "7000助家生活")

            manifestPlaceholders.put("BD_MAP_API_KEY", "1pPALTmbxveNnEB9AmjZ0wCW")
            manifestPlaceholders.put("UMENG_APPKEY", "568cbf7e67e58ea74f000143")
        }
    }
    dexOptions {
        javaMaxHeapSize "4g"
        preDexLibraries = false

    }
    packagingOptions {
        exclude 'META-INF/services/javax.annotation.processing.Processor'
    }
}
//删除unaligned文件的任务
task deleteUnalignedFiles(type: Delete) {
    delete fileTree('./build/outputs/apk') {
        include '*unaligned.apk'
    }
}

walle {
    // 指定渠道包的输出路径
    apkOutputFolder = new File("${project.buildDir}/outputs/channels");
    // 定制渠道包的APK的文件名称
    apkFileNameFormat = '${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk';
    // 渠道配置文件
//    channelFile = new File("${project.getProjectDir()}/channel.txt")
    // 渠道&额外信息配置文件，与channelFile互斥
    configFile = new File("${project.getProjectDir()}/config.json")
}

dependencies {
    def dependence = rootProject.ext.dependencies
    testCompile rootProject.ext.testDependencies.junit
    testCompile rootProject.ext.testDependencies.robolectric
    compile fileTree(include: ['*.jar'], dir: 'libs')

    apt dependence.daggerCompiler
    provided dependence.javaxAnnotation
    provided dependence.tinkerAndroidAnno

    compile dependence.androidSupportMultidex
    compile dependence.androidSupportV7
    compile dependence.androidSupportDesign
    compile dependence.androidSupportPercent
    compile dependence.slidingUpPanel
    compile dependence.butterKnife
    compile dependence.dagger
    compile dependence.rxJava
    compile dependence.rxAndroid
    compile dependence.swipeLayout
    compile dependence.walle
    compile dependence.glideTransformation
    compile dependence.eventBus
    compile dependence.roundImageView
    compile dependence.bgaQrcodecore
    compile dependence.bgaZxing
    compile dependence.recyclerviewv7
    compile dependence.cardviewv7
    compile dependence.tinkerAndroidAnno
    compile dependence.tinkerAndroidLib
    compile dependence.pinyin
    compile dependence.buglyCrashreport
    compile dependence.buglyNativecrashreport
    compile dependence.systembartint
    compile dependence.palette
    compile dependence.growingio
    compile dependence.photoview
    compile dependence.ShadowViewHelper
    compile dependence.smoothAppbarLayout
    compile dependence.rxbinding
    compile dependence.rxbindingDesign
    compile dependence.jpush  //极光推送
    compile dependence.jcore  //极光推送
    compile dependence.skeleton
    compile dependence.circleimageview
    compile dependence.Banner
    compile dependence.constraintLayout
    compile dependence.permission

    compile('com.github.afollestad.material-dialogs:core:0.8.5.7@aar') {
        transitive = true
    }
    compile project(':common')
    compile project(':kefu-easeui')
    compile project(':domain')
    compile project(':runtime_permission')

    releaseCompile project(path: ':data', configuration: 'release')
    debugCompile project(path: ':data', configuration: 'debug')
    developerCompile project(path: ':data', configuration: 'developer')
}

//微信tinker 配置

def gitSha() {
//若不使用git作为tinkerid改为versionName
    return android.defaultConfig.versionName;

//    //将git版本号设置为TINKER_ID
//    try {
//        String gitRev = 'git rev-parse --short HEAD'.execute(null, project.rootDir).text.trim()
//        if (gitRev == null) {
//            throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
//        }
//        return gitRev
//    } catch (Exception e) {
//        throw new GradleException("can't get git rev, you should add git to system path or just input test value, such as 'testTinkerId'")
//    }
}

def getTinkerIdValue() {
    //如果没有指定TINKER_ID，就会通过gitSha()方法获取
    return hasProperty("TINKER_ID") ? TINKER_ID : gitSha()
}

//定义安装包路径。每次build时，如assembleDebug都会在bakApk目录下生成打包好的apk文件
def bakPath = file("${buildDir}/bakApk/")

/**
 * you can use assembleRelease to build you base apk
 * use tinkerPatchRelease -POLD_APK=  -PAPPLY_MAPPING=  -PAPPLY_RESOURCE= to build patch
 * add apk from the build/bakApk
 */
ext {
    //这里是控制tinker开关的，平时debug的时候可以选择关闭
    //for some reason, you may want to ignore tinkerBuild, such as instant run debug build?
    tinkerEnabled = false

    //这里是old.apk的路径，在第二次打包时必须手动修改为第一次打包保留下的apk存放路径
    //下面示例中的时分秒非必要不要动了，我就是把分秒删了，在同一时段内造成相同报名覆盖而看不到效果，这是一个悲剧
    //for normal build
    //old apk file to build patch apk
    tinkerOldApkPath = "${bakPath}/app-developer-0809-11-42-48.apk"
    //mapping.txt同上，需换成第一次打包是保留的存放路径
    //proguard mapping file to build patch apk
    tinkerApplyMappingPath = "${bakPath}/app-developer-0809-11-42-48-mapping.txt"
    //同上，这个也必需改，不然会报错
    //resource R.txt to build patch apk, must input if there is resource changed
    tinkerApplyResourcePath = "${bakPath}/app-developer-0809-11-42-48-R.txt"

    //only use for build all flavor, if not, just ignore this field
    tinkerBuildFlavorDirectory = "${bakPath}/app-developer-0809-11-09-15-R.txt"
}

def getOldApkPath() {
    return hasProperty("OLD_APK") ? OLD_APK : ext.tinkerOldApkPath
}

def getApplyMappingPath() {
    return hasProperty("APPLY_MAPPING") ? APPLY_MAPPING : ext.tinkerApplyMappingPath
}

def getApplyResourceMappingPath() {
    return hasProperty("APPLY_RESOURCE") ? APPLY_RESOURCE : ext.tinkerApplyResourcePath
}

def buildWithTinker() {
    return hasProperty("TINKER_ENABLE") ? TINKER_ENABLE : ext.tinkerEnabled
}

def getTinkerBuildFlavorDirectory() {
    return ext.tinkerBuildFlavorDirectory
}

if (buildWithTinker()) {
    apply plugin: 'com.tencent.tinker.patch'

    tinkerPatch {//跟命令行介入时的tinker_config.xml中的配置差不多，可根据自己情况做相应修改
        /**
         * necessary，default 'null'
         * the old apk path, use to diff with the new apk to build
         * add apk from the build/bakApk
         */
        oldApk = getOldApkPath()
        /**
         * optional，default 'false'
         * there are some cases we may get some warnings
         * if ignoreWarning is true, we would just assert the patch process
         * case 1: minSdkVersion is below 14, but you are using dexMode with raw.
         *         it must be crash when load.
         * case 2: newly added Android Component in AndroidManifest.xml,
         *         it must be crash when load.
         * case 3: loader classes in dex.loader{} are not keep in the main dex,
         *         it must be let tinker not work.
         * case 4: loader classes in dex.loader{} changes,
         *         loader classes is ues to load patch dex. it is useless to change them.
         *         it won't crash, but these changes can't effect. you may ignore it
         * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build
         */
        ignoreWarning = false

        /**
         * optional，default 'true'
         * whether sign the patch file
         * if not, you must do yourself. otherwise it can't check success during the patch loading
         * we will use the sign config with your build type
         */
        useSign = true

        /**
         * optional，default 'true'
         * whether use tinker to build
         */
        tinkerEnable = buildWithTinker()

        /**
         * Warning, applyMapping will affect the normal android build!
         */
        buildConfig {
            /**
             * optional，default 'null'
             * if we use tinkerPatch to build the patch apk, you'd better to apply the old
             * apk mapping file if minifyEnabled is enable!
             * Warning:
             * you must be careful that it will affect the normal assemble build!
             */
            applyMapping = getApplyMappingPath()
            /**
             * optional，default 'null'
             * It is nice to keep the resource id from R.txt file to reduce java changes
             */
            applyResourceMapping = getApplyResourceMappingPath()

            /**
             * necessary，default 'null'
             * because we don't want to check the base apk with md5 in the runtime(it is slow)
             * tinkerId is use to identify the unique base apk when the patch is tried to apply.
             * we can use git rev, svn rev or simply versionCode.
             * we will gen the tinkerId in your manifest automatic
             */
            tinkerId = getTinkerIdValue()

            /**
             * if keepDexApply is true, class in which dex refer to the old apk.
             * open this can reduce the dex diff file size.
             */
            keepDexApply = false
        }

        dex {
            /**
             * optional，default 'jar'
             * only can be 'raw' or 'jar'. for raw, we would keep its original format
             * for jar, we would repack dexes with zip format.
             * if you want to support below 14, you must use jar
             * or you want to save rom or check quicker, you can use raw mode also
             */
            dexMode = "jar"

            /**
             * necessary，default '[]'
             * what dexes in apk are expected to deal with tinkerPatch
             * it support * or ? pattern.
             */
            pattern = ["classes*.dex",
                       "assets/secondary-dex-?.jar"]
            /**
             * necessary，default '[]'
             * Warning, it is very very important, loader classes can't change with patch.
             * thus, they will be removed from patch dexes.
             * you must put the following class into main dex.
             * Simply, you should add your own application {@code tinker.sample.android.SampleApplication}
             * own tinkerLoader, and the classes you use in them
             *
             */
            loader = [
                    //use sample, let BaseBuildInfo unchangeable with tinker
                    "tinker.sample.android.app.BaseBuildInfo"
            ]
        }

        lib {
            /**
             * optional，default '[]'
             * what library in apk are expected to deal with tinkerPatch
             * it support * or ? pattern.
             * for library in assets, we would just recover them in the patch directory
             * you can get them in TinkerLoadResult with Tinker
             */
            pattern = ["lib/*/*.so"]
        }

        res {
            /**
             * optional，default '[]'
             * what resource in apk are expected to deal with tinkerPatch
             * it support * or ? pattern.
             * you must include all your resources in apk here,
             * otherwise, they won't repack in the new apk resources.
             */
            pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]

            /**
             * optional，default '[]'
             * the resource file exclude patterns, ignore add, delete or modify resource change
             * it support * or ? pattern.
             * Warning, we can only use for files no relative with resources.arsc
             */
            ignoreChange = ["assets/sample_meta.txt"]

            /**
             * default 100kb
             * for modify resource, if it is larger than 'largeModSize'
             * we would like to use bsdiff algorithm to reduce patch file size
             */
            largeModSize = 100
        }

        packageConfig {
            /**
             * optional，default 'TINKER_ID, TINKER_ID_VALUE' 'NEW_TINKER_ID, NEW_TINKER_ID_VALUE'
             * package meta file gen. path is assets/package_meta.txt in patch file
             * you can use securityCheck.getPackageProperties() in your ownPackageCheck method
             * or TinkerLoadResult.getPackageConfigByName
             * we will get the TINKER_ID from the old apk manifest for you automatic,
             * other config files (such as patchMessage below)is not necessary
             */
            configField("patchMessage", "tinker is sample to use")
            /**
             * just a sample case, you can use such as sdkVersion, brand, channel...
             * you can parse it in the SamplePatchListener.
             * Then you can use patch conditional!
             */
            configField("platform", "all")
            /**
             * patch version via packageConfig
             */
            configField("patchVersion", "1.0")
        }
        //or you can add config filed outside, or get meta value from old apk
        //project.tinkerPatch.packageConfig.configField("test1", project.tinkerPatch.packageConfig.getMetaDataFromOldApk("Test"))
        //project.tinkerPatch.packageConfig.configField("test2", "sample")

        /**
         * if you don't use zipArtifact or path, we just use 7za to try
         */
        sevenZip {
            /**
             * optional，default '7za'
             * the 7zip artifact path, it will use the right 7za with your platform
             */
            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
            /**
             * optional，default '7za'
             * you can specify the 7za path yourself, it will overwrite the zipArtifact value
             */
//        path = "/usr/local/bin/7za"
        }
    }

    //这里是多渠道打包和将打好的包copy的bakApk目录的代码
    List<String> flavors = new ArrayList<>();
    project.android.productFlavors.each { flavor ->
        flavors.add(flavor.name)
    }
    boolean hasFlavors = flavors.size() > 0
    /**
     * bak apk and mapping
     */
    android.applicationVariants.all { variant ->
        /**
         * task type, you want to bak
         */
        def taskName = variant.name
        def date = new Date().format("MMdd-HH-mm-ss")

        tasks.all {
            if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {

                it.doLast {
                    copy {
                        def fileNamePrefix = "${project.name}-${variant.baseName}"
                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"

                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
                        from variant.outputs.outputFile
                        into destPath
                        rename { String fileName ->
                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
                        }

                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
                        }

                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
                        }
                    }
                }
            }
        }
    }

    //多渠道的时候用到
    project.afterEvaluate {
        //sample use for build all flavor for one time
        if (hasFlavors) {
            task(tinkerPatchAllFlavorRelease) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"

                    }

                }
            }

            task(tinkerPatchAllFlavorDebug) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
                    }

                }
            }
        }
    }
}

